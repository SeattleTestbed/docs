== Exploring the Delay Space with Seattle ==
[[TOC(inline)]]

'''Under construction'''.

=== Modified divide-and-conquer algorithm ===
[[Image(allpairsping.png, 200px, right, nolink)]]
The all-pairs-ping algorithm we use is based on a modified divide-and-conquer algorithm. We use a central coordination instance to avoid interferences between each measurement trial.
To obtain the latency matrices, we implemented the two following programs: the "controller" program, which is monitoring and controlling the steps of the divide-and-conquer algorithm, and the "node" program, which is responsible for performing the measurements on each tested Seattle vessel.

==== Controller ====
This program [raw-attachment:controller.repy] is repsonsible for the execution of the divide-and-conquer algorithm and for the coordination of the measurement rounds. It may only be installed on one Seattle vessel to coordinate all vessels on which the "node" program is running. For this purpose, it obtains a list ''S'' with the IPs of all Seattle nodes to measure.[[BR]]
In the divide step the list ''S'' is split into two sublists ''S,,1,,'' and ''S,,2,,''. If the length of ''S'' is odd, ''S,,1,,'' receives the last remaining node.[[BR]]
[[Image(conquer.png, 480px, nolink)]][[BR]]
In the conquer phase, the controller sends a message to each node of the sublist ''S,,1,,'' to indicate, which node of ''S,,2,,'' should be measured. Furthermore, by permuting the measured list, the controller will ensure that all possible pairs are measured. By switching the sublists thereafter and restarting the conquer step, it will perform all measurements bidirectionally.[[BR]]
When the measurements have been performed bidirectionally and the length of one of the remaining sublists is greater than one, the divide-and-conquer algorithm starts with this sublist recursively again.
The program is started in ''seash.py'' by executing:[[BR]]
{{{
#!repy 
controller.repy [port] [ipfile] [measures] [waittime]
}}}

    - [port]: Your specific port for Seattle
    - [ipfile]: A file you uploaded to the controller Vessel with all IPs that should be measured
    - [measures]: The number of measurements that should be performed
    - [waittime]: A specific waiting time between each measurement

==== Node ====
[[Image(measurements.png, 360px, right, nolink)]]
The program [raw-attachment:node.repy] is responsible for the execution of the measurements. It is executed on all Seattle vessels which should be measured. Being governed by the controller each node will produce a list of ''n'' measurements with a specific waiting time ''t'' between each try.[[BR]]
The program is started in ''seash.py'' by executing:
{{{
#!repy 
node.repy [port]
}}}

    - [port]: Your specific port for Seattle

=== Executing the programs ===
To get the programs operating, first acquire your vessels and exclude one node from the whole group; second run "node.repy" on all members of the group, acquire their IPs to a file and third upload the IP file to the node, that was removed from the group, and run "controller.repy" on it.

=== Calculations ===
For the statistical analysis of the collected data we implemented the following: the quantils, the mean value and an estimation of the variance and the deviation.

==== Mean value ====
{{{
#!repy
def calcmean(floatlist):
    result = 0.0
    for f in floatlist:
        result += f
    if len(floatlist) > 0:
        result /= len(floatlist)
    return result
}}}

==== Estimation of the variance and deviation ====
{{{
#!repy
def calcestimate(floatlist):
    result = 0.0
    mean = calcmean(floatlist)
    for f in floatlist:
        result += (f - mean) ** 2
    if len(floatlist) > 1:
        result /= (len(floatlist) - 1)
    else:
        result = 0
    return result
}}}

{{{
#!repy
def calcdeviation(floatlist):
    result = calcestimate(floatlist)
    result = result ** .5
    return result
}}}

==== Quantils ====
{{{
#!repy
def calcquantil(sortedfloatlist, quantil=0.25):
    result = 0
    n = len(sortedfloatlist)
    datapoint = n * quantil
    if int(datapoint) is not 0:
        if datapoint % int(datapoint) > 0:
            datapoint = int(datapoint)
            result = sortedfloatlist[int(datapoint)]
        else:
            result = (sortedfloatlist[int(datapoint - 1)] + sortedfloatlist[int(datapoint)]) / 2
    return result
}}}

=== Displaying the results ===


== Results ==
The results of the first test of 50 nodes is represented in [raw-attachment:latencymap.csv]. This map contains the mean values of the 50 percent quantil reduced measure lists between two nodes[[BR]]
In [raw-attachment:measuremap.csv] all results are presented row wise with the additional information of the distances between the nodes and their location.