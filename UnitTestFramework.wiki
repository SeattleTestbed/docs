= Seattle's Unit Test Framework Draft =

----
[[TOC(inline)]]
----

[[BR]]
== Tutorials ==
----

You think writing tests is difficult, annoying and fruitless work? I beg to differ. Read through these tutorials and I am sure you will agree. They should help you get familiar with all the features in the Unit Testing Framework (UTF). We will go over some simple and straightforward examples. Each of the examples is intended to provide a use case for a specific feature.

[[BR]]
=== Introduction ===
----

So, you are writing a piece of software whose API has been defined and maybe implemented, and now you would like to start testing its behavior. The component you are testing is a resource monitor. For the sake of simplicity, suppose there are only two methods implemented in this file.

{{{
#!python

"""
File: monitor.py
"""

def add_host(host_name): ...
def list_hosts(): ...
}}}


[[BR]]
=== Naming Requirements ===
----

First thing you need to do is create a test file. Every test file has to follow a very specific naming convention -- otherwise, it will fail to be registered by UTF. There are two components to it:

 * Module Name -- Everything that you will be writing for Seattle is a smaller component (or a module) of the entire Seattle framework. Thus, we need to give it an appropriate name.

 * Descriptor -- Is an optional attribute. It is used to distinguish between different test files withing the same module.

Putting this together, we get:

{{{
#!python

ut_MODULE[_DESCRIPTOR].py

}}}

Since we are designing a resource monitor, let us call our module ''monitor''. Go ahead and create that file. 

{{{
#!python

"""
File: ut_monitor.py
"""
}}}

[[BR]]
=== Basics ===
----

Now, we start writing test cases. You write them the same way you would any python executable. The only thing to remember is that by default your test file is not allowed to produce any output on stdout or stderr. This is how UTF is able to tell if your test file has run successfully.

{{{
#!python

"""
File: ut_monitor_testhostnames.py
"""

# import your module.
import monitor

# Test valid host names.
def test_valid_add():

  valid_host_names = ('google.com', '128.208.1.1', '127.0.0.1')
  
  for host_name in valid_host_names:
    monitor.add_host(host_name)

  available_hosts = monitor.list_hosts()
  if len(available_hosts) != len(valid_host_names):
    print 'Adding valid host names failed.'


# Test invalid host names.
def test_invalid_add():

  invalid_host_names = ('...', '0.0.0.0')
  for host_name in invalid_host_names:
    try: 
      monitor.add_host(host_name)
    except InvalidHostName:
      pass
    else: 
      print 'Adding invalid host did not raise an exception'

}}}

[[BR]]
=== Invocation ===
----

Logically, now you would like to run your tests. This is done by invoking '''utf.py'''. When running tests, you are presented with three different possibilities:

 * Run all tests for all modules in the current directory:

{{{
#!python

$ utf.py

}}}

 * Run all tests for a specific module

{{{
#!python

$ utf.py --module <module name>
$ utf.py -m <module name>

}}}

 * Run a specific test file.

{{{
#!python

$ utf.py --file <file>
$ utf.py -f <file>

}}}

All you have to do now is run the UTF, specifying ''monitor'' as the module to test.

{{{
#!python

$ utf.py -m monitor
Testing module: monitor
  Running ut_monitor.py                   [ PASS }

$
}}}

Great! It works!

[[BR]]
=== Multiple Test Files ===
----

You might require more than one test for a module. To create multiple unit tests for one module, all you need to do is use the same naming convention we described earlier. In our case where we were testing the 'monitor' module, we used the name 'ut_monitor_firsttest.py'. All we need to do is use the same module descriptor. For example, you might use 'ut_monitor_secondtest.py' as your second unit tests' name. Keep in mind that when choosing a descriptor for your filename, you should be as descriptive as possible (if you were testing disk usage, a good name for your test would be 'ut_monitor_diskusage.py'). 

{{{
#!python

# Resource Monitor -- Host Availability.
$ mv ut_monitor.py ut_monitor_hosts.py

# Resource Monitor -- Disk Usage.
$ vim ut_monitor_disk.py

}}}

After you're done writing test cases for the new functionality, simply run UTF once more.

{{{
#!python

$ utf.py -m monitor
Testing module: monitor
  Running ut_monitor_hosts.py               [ PASS }
  Running ut_monitor_disk.py                [ PASS }
$
}}}


[[BR]]
=== Repy ===
----

Another feature of UTF is the support for testing repy files.  

Writing repy test cases is pretty simple. Imagine you are writing a synchronization primitive (semaphore) which has four methods defined.

{{{
#!python

def create_semaphore(): ...
def destroy_semaphore(handle): ...
def up(handle): ...
def down(handle): ...
}}}


And you decide to test it by creating an appropriate test file.

{{{
#!python
"""
File: ut_semaphore_testrepy.py
"""
}}}
UTF has to be able to differentiate between Python and Repy. Therefore, there must be a way to instruct the testing framework that this file is suppose to be executed inside of the Repy Execution Environment. To achieve this you need to insert, what is called, a '''pragma directive''' at the beginning of the test file. Each pragma directive instructs UTF in how to behave.

Here is the general form of a pragma:
{{{
...

#pragma TYPE [ARGS]

...
}}}



For this specific purpose use ''#pragma repy'' directive. Whenever UTF encounters this directive, it knows it has to execute the test file inside of the Repy Execution Environment. This directive must be inserted on its own line, somewhere in the file (a good convention is to put it near the top).

The rest of the file is written as a regular Repy file. Just as with Python testing, by default your unit test will fail if there is anything written on standard out or standard error. 

{{{
#!python

#pragma repy


def test_create():
def test_destroy():
def test_up():
def test_down():
}}}

[[BR]]
==== Repy Restrictions ====
----

Repy execution is always associated with a restrictions file. To use a specific restrictions file, append it to the pragma directive as an argument. As with the previous example, if no argument was provided to #pragma repy directive, UTF assumes default restrictions are to be used. Therefore,


{{{
#!python

#pragma repy
}}}

is equivalent to:

{{{
#!python

#pragma repy restrictions.default
}}}

For instance, if your test file is suppose to be executed using non-default restrictions (i.e. restrictions.callomit) you would be using #pragma repy restrictions.omitcall (the restriction file we are using does not allow function calls).
 
[[BR]]
==== Standard Out/Error ====
----
Remember, by default UTF will cause a test to fail if there is anything written to standard out or standard error. However, if you do need to have a specific output on standard out, there is a way for UTF distinguish between bad output and good output. We need to use ''#pragma out'' directive. What this says is that the test file which is being executed is supposed to produce output on standard out. Likewise, there is also a way for UTF to ignore certain error messages (for example if you're testing whether an error happens when it's supposed to). In this case, use the ''#pragma error'' directive.

{{{
#!python

# This is a repy file!
#pragma repy

# This must be a substring of standard out for the test to pass.
#pragma out Hello Out.

print 'Hello Out.'
}}}

UTF will check to see that the entire string of words following the directive is written to standard out or standard error. If the string was not there, the test will fail.

If no output is specified as an argument to the directive, UTF will ignore all output to standard out or standard error, depending on which pragma directive you used.

[[BR]]
=== Setup Shutdown Scripts ===
----
Some software modules require additional steps before and after the test execution. We refer to those as ''setup'' and ''shutdown'' scripts receptively.

Suppose we are testing an IO module with several functions defined.

{{{
#!python

def open(file_path): ...
def read(handle) ...
def write(handle): ...
def truncate(handle): ...
def stat(handle): ...
...
}}}

And you decide to start testing. You notice that every test requires some sort of file cleanup. Instead of doing the cleanup after every test case, it is much easier to do this in bulk. So we introduce what is called a '''shutdown script'''. It is guaranteed that this script will run last.

{{{
#!python

import os

# Remove the directory.
def remove_tmp():
  temporary_dir = '/tmp/io'
  os.rmdir(temporary_dir)



if __name__ == '__main__':
  remove_tmp()
}}}


Basically, the same logic applies for setup scripts, however, opposite holds true -- it is first script to be executed.


[[BR]]
== User's guide ==
----


=== Requirements ===

Here we specify requirements, so that the users have a better understanding of what the goals are. 

 * Above everything, writing a unit test module should be simple and obvious for new users.
 * Test module should be able to have many small test cases and developer should be able to group them into test suites.
 * The framework should allow advanced users to perform non-trivial tests.
 * The framework should allow users to easily select what tests to run (whole module or specific test cases).
 * The framework back-end needs to be simple and extensible.

When translating requirements into objectives, we are faced with a non-trivial task, since some requirements are more important than others. As a result, advanced features are somewhat limited (for instance there is not support for test trees).


=== Design ===

 * Testing within '''Repy execution environment'''.
 * Ability to specify different '''restrictions''' for different Repy test files.
 * Testing for '''standard out and standard error''' messages.
 * Support for '''setup and shutdown scripts'''.

Having this in mind, you are probably asking yourself: 'Well, how do I achieve this?'. Obviously, we need to be able to hint or to instruct the framework about our needs. Those instructions are embedded '''either in the file itself or the filename'''. Below, we discuss each aspect.

When instructing the UTF:

 * that the test file is suppose to be run inside the Repy execution environment,
 * or to use a non-default restrictions file,
 * or that the executed test has to produce a specific output on standard out or/and standard error

we need to use the following syntax withing the test file:

{{{
#!python

#DIRECTIVE TYPE [ARGS]
}}}

The directive name is always going to be '''pragma''' (a directive communicating additional "pragmatic" or implementation-specific information). Therefore, the more specific syntax is:

{{{
#!python

#pragma TYPE [ARGS]
}}}

The following #pragma directives are allowed. When an unknown #pragma directive is encountered, UTF reports an error.

{{{
#!python
"""
Instructs UTF that this test file is suppose to be run inside Repy execution environment. 
Restriction file argument is optional -- if not specified restrictions.default is used.
If this directives is omitted, UTF assumes that your test file is a standard Python
file.
"""
#pragma repy [RESTRICTIONS FILE]

"""
Instructs UTF that this test file is suppose to produce some output on standard out. 
If the TEXT argument is specified, UTF will try to find TEXT substring within standard out. 
If TEXT is not specified, UTF makes sure that the standard out data is not empty.
"""
#pragma out [TEXT]

"""
Instructs UTF that this test file is suppose to produce some output on standard error. 
If the TEXT argument is specified, UTF tries to find TEXT substring within standard error. 
If TEXT is not specified, UTF makes sure that the standard error data is not empty.
"""
#pragma error [TEXT]
}}}

[[BR]]
----
[[BR]]

Other features are encoded inside of the ''' filename'''. Those are:

 * Which module does the test file belong to.
 * Does the module have setup and shutdown scripts?
 * Whether or not the test file will be executed by default.

All test files have to follow a strict naming convention: 

{{{
#!python

ut_<module name>_<descriptor>.py.
}}}

A module can have multiple test files associated with it.

Furthermore, a module may contain two special descriptors: '''setup''' and '''shutdown'''. When running full module testing, ut_<module>_setup.py is executed at the '''beginning''' and ut_<module>_shutdown.py at the '''end''' of the execution. This is primarily used by more complicated modules, which require initialization and clean-up steps.

Test files with the above mentioned syntax are executed '''by default'''. To exclude them from default execution, '''prepend the filename with _'''. This way, the test file has to be executed '''explicitly'''.

[[BR]]
----
[[BR]]

When running tests, a developer is presented with three different possibilities:
 * Run all tests for all modules:

{{{
#!python

$ utf.py

}}}

 * Run all tests for a specific module

{{{
#!python

$ utf.py --module <module name>
$ utf.py -m <module name>

}}}

 * Run a specific test file.

{{{
#!python

$ utf.py --file <file>
$ utf.py -f <file>

}}}