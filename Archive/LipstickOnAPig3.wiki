= Lipstick on a Pig =
 * 
= Overview =


== Exception Handling ==


Coding Sprint: Feb ?th

Jan 10th - Jan 17th

Mitchell: Examine exception hierarchy of Java or Python.   Make notes on one type of call (file I/O, nw, etc.).

Andreas: Look at the sort of exceptions Repy might generate and what should be thrown.   Try to finish one type of call (file I/O, nw, etc.).

Both: Synchronize so that you look at the same call type (file I/O, nw, etc.)

Jan 17th - Jan 24nd

Mitchell: Examine exception hierarchies of other popular languages.   "Present" in meeting

Andreas: Complete looking over all repy call types

Jan 24th - Jan 31st

TBD -- discussed in meeting.


==== Exceptions in Repy ====
The exceptions generated by Repy vary in their causes, and currently there is no homogeneity in how they are handled. 

 * Safety exceptions regarding unsafe/unpermitted calls. Currently there is a {{{SafeException}}}, which is subclassed by {{{CheckNodeException}}}, {{{CheckStrException}}}, and {{{RunBuiltinException}}}
 * processing the restrictions file can raise parsing errors; could be considered IO error?
 * include statements can error if file doesn't exist: IO
 * Resource exceptions, if any nonrenewable resource exceeds its limits. Currently these all just raise the Exception class, and there are a few internal errors that are also raised if state gets corrupted
 * The repy library calls can raise their own exceptions, depending on the call. For example, {{{gethostbyname_ex}}} just calls {{{socket.gethostbyname_ex}}}, and doesn't bother wrapping any thrown exceptions. Should we wrap these library calls with our own exceptions? What if 
 * softwareupdater has its own class of errors ({{{RsyncError}}})