# Lipstick on a Pig

# Overview

The purpose of this Strike Force is to improve the usability of the Repy language.   In particular, we focus on exception handling, seattle lib clean up, and Repy <-> Python portability.



## Exception Handling

Our Exception Hierarchy [LipstickExceptionProposal proposal]

## Calendar

Coding Sprint: Feb ?th

Jan 10th - Jan 17th

Mitchell: Examine exception hierarchy of Java or Python.   Make notes on one type of call (file I/O, nw, etc.).

Andreas: Look at the sort of exceptions Repy might generate and what should be thrown.   Try to finish one type of call (file I/O, nw, etc.).

Both: Synchronize so that you look at the same call type (file I/O, nw, etc.)

Jan 17th - Jan 24nd

Mitchell: Examine exception hierarchies of other popular languages.   "Present" in meeting

Andreas: Complete looking over all repy call types

Jan 24th - Jan 31st

TBD -- discussed in meeting.


#### Exceptions in Repy
The exceptions generated by Repy vary in their causes, and currently there is no homogeneity in how they are handled. 

 * Safety exceptions regarding unsafe/unpermitted calls. Currently there is a ```SafeException```, which is subclassed by ```CheckNodeException```, ```CheckStrException```, and ```RunBuiltinException```
 * processing the restrictions file can raise parsing errors; could be considered IO error?
 * include statements can error if file doesn't exist: IO
 * Resource exceptions, if any nonrenewable resource exceeds its limits. Currently these all just raise the Exception class, and there are a few internal errors that are also raised if state gets corrupted
 * The repy library calls can raise their own exceptions, depending on the call. For example, ```gethostbyname_ex``` just calls ```socket.gethostbyname_ex```, and doesn't bother wrapping any thrown exceptions. Should we wrap these library calls with our own exceptions? What if 
 * softwareupdater has its own class of errors (```RsyncError```)

#### Exceptions in Repy Applications

 * A lot of network exceptions since all apps seem to have something to deal with talking with other nodes (Unable to connect, connection lost, timeout, etc.)
 * Pure Python value errors, invalid types, division by zero, etc.
 * Disk IO errors - Some apps log to files or read files so there can be disk IO problems
 * Syntax error

We can't expect to be able to catch and wrap syntax errors and other pure python errors that are thrown in the userspace since its too high above Repy. But since network, disk IO, etc. go through repy we'd be able to catch and wrap those exceptions quite nicely into a RepyException.

I gave some time to thinking about a proper hierarchy for our exceptions. Python itself seems to have very little organization in its exception hierarchy (http://www.python.org/doc/essays/stdexceptions.html). The thoughts I had:

```
RepyException
 |
 +-- IOException
   |
   +-- DiskIOException
   +-- NetworkIOException
 +-- UnsafeException
 +-- SystemException (out of memory, system error, a "recoverable" harsh exit?)
 +-- PythonException
   |
   +-- ValueError
   +-- SyntaxError
   +-- etc. (PythonException "wraps" pure python exceptions?)
```

The above is just a beginning of an attempt at brainstorming an exception hierarcy.


## These are some observations we made after going through the Repy library.
```
All library calls could raise an error if a function is used that isn't allowed by the restrictions file. 

*** emulcomm.py ***

* gethostbyname_ex
  *general socket errors 
  *expects string
  
* getmyip
  *general socket errors
  
* stopcomm
  nothing
  
* sendmess
  *socket errors
  *argument errors
    *expects int/long on dest and src ports
  *resource errors on send quantitites?
    *try to access ports/local ip not allowed
    
    
* recvmess
  *expects string, int/long, and function pointer that expects 4 arguments
  *resource error
    *port/ip not allowed
  *socket errors
  
  
*openconn
  *expects string, int/long, string, int/long, float/None
  *socket errors
  
* waitforconn
  *expects string, int/long, function pointer that takes 5 arguments
  *resource error
    *port/ip not allowed
  *socket errors
  
  
*** emulfile.py ***  

* listdir

* removefile
  *expects string
  *filename not allowed exception


* emulated_file
  * __init__
    * invalid filename
    * resource error
      *too many files

*** emulmisc.py ***  
None!


*** emultimer.py ***
* sleep
  * expects number
  * IOError if arg < 0
  
* settimer
  *expects int, functioncall, tuple/list
  
  
============= 
  
  
Regular Python Exceptions we want to use:
* TypeError
* ValueError


RepyException
 |
 +-- NetworkError
 +-- ResourceError
   |
   +-- ResourceExhaustedError
PythonException
 |
 +-- ValueError
 +-- TypeError
 +-- etc. (PythonException "wraps" pure python exceptions?)
```

### List of Library Calls And Their Problems
This is an ongoing list of problems discovered in library calls found during repy testing about possible mistakes users could make

#### sendmess
 Performs almost no argument checking
 * If desthost isn't a string, raises AttributeError (object doesn't have startswith attribute!)
 * Does no check on destport, allowed to be 800000!
 * When third argument (message) isn't a string throws a typeerror saying ```sendto``` needs 3 args, given 2...
 
#### recvmess
 * Checks on localip are loose: allows binding of local ip to string "1234", but does complain about unicode coercing if not string
 * socket.error if cannot assign requested address
 * no checks performed to see if the callback has proper arguments

#### stopcomm
 * Just checks to see if the argument is in the dict of existing connections, returns if not. Should this be more picky about arguments, tell users a little bit more about why it returned immediately?

#### getmyip
 * Doesn't tattle any netsend/netrecv traffic

#### Files
 * The mode checks are pretty loose
 * Tried breaking resource checks using seek and then write, unsuccessful. 
 
#### Python Builtins provided in Repy
The python builtins provided in repy (defined in [source:/seattle/trunk/repy/safe.py safe.py] and [source:/seattle/trunk/repy/repy.py repy.py]) overwhelmingly favor TypeError when passed an argument of incorrect type, and ValueError when passed bad values (negative, out of range, etc). We should probably do the same

### Todo list for testing
Uncertainty's faced while writing unit tests
 * There are many problems/scenarios that were difficult to simulate in unit tests
    * Disconnected network connection, whether at start of program or during execution
    * Changing IP address
    * Disk IO errors: full, permission denied, etc

### Revised Proposed Exception Heirarchy
```
RepyError
 |
 +-- IOError
   |
   +-- NetworkError
     |
     +--AddressError (wrapper for socket.gaierror and socket.herror)
     +--DisconnectedError (whether from the start, or suddenly)
     +--TimeoutError (when a host times out)
   +-- DiskError
     |
     +--FileNotFoundError
     +--InvalidFileModeError
   +-- ResourceError
     |
     +-- ResourceExhaustedError (too many files opened/used?)
     +-- ResourceNotAllowedError (using a port that's not allowed)
     
 +-- UnsafeCallError (python call not allowed in repy)
PythonException
 |
 +-- ValueError (these two are particularly important for library call's performing argument checks)
 +-- TypeError 
 +-- 
 +-- Any exceptions raised by python builtins: KeyError (dicts)
 +-- Builtins generated by programmer mistakes: AttributeError, IndexError, NameError
```

## Improving Seash

Consider using the [cmd module](http://docs.python.org/library/cmd.html#module-cmd) for making seash more robust and improving the readability of its code. A good tutorial for this module can be found [here](http://www.doughellmann.com/PyMOTW/cmd/index.html).