= Top Secret =

 * TCP over UDP flow control
 * anonymous donation
 * other interactions with Tor project. 

= Overview =

To begin, this force will focus on multiplexing multiple reliable connections over UDP. This resembles TCP over UDP except (to start with) a single UDP connections is used for multiplexing multiple connections. Later on, this force will shift gears and move towards coordinating with the Tor project to handle anonymous donations by nodes that are running Tor.

If you do not have a sufficient background in networking, you should find a copy of Peter and Davie's 'Computer Networks' book and read the following chapter (listed for the 3rd edition of the book): 1, 2.4, 2.5, 5.1, 5.2, 6.

= Meetings =

We meet 12:30-1:30pm on Wednesdays in CSE 314.

= Week 1 =

 * Implementation of StopAndWaitAssignment in repy
 * Read Chapters 1, 2.4 and 2.5 from Peterson and Davie

= Week 2 =

 * Mike : 3-way handshake
 * Richard : Sliding window
 * Andreas : complete StopAndWaitAssignment and finish reading
 * Ivan : external repy interface

= Week 3 =

 * Mike : 3-way handshake integration with Richard's codebase
 * Andreas : Controller class design and implementation for multiplexing and de-multiplexing TCP library connections onto a single internal UDP connection
 * Richard : Convert sequence numbers from numbering packets to numbering bytes. Also, support Mike and Andreas in their interactions with the codebase.
 
= Future =

 * Flow control: sliding window, and window scaling (for high bandwidth links)
 * Cumulative acknowledgments
 * Piggy-backing Acks on data -- extending header
 * TCP timestamps and seq wrap-around protection
 * Selective acknowledgments (SACK)
 * Three way handshake
 * Closing (four-way and three-way) handshake
 * RTT estimation (Karn's algorithm and SRTT computation)
 * Congestion control: congestion window, slow start, congestion avoidance
 * Ports for multiplexing connections
 * PMTU discovery for MSS estimate (possible in python/repy?)
 * Benchmarking
   * Performance comparison against vanilla TCP (LAN)
   * Fairness comparison against vanilla TCP (LAN)
   * Scalability

= Common Classes, Methods, and Exceptions = 

 * Class Connection
   * Internal state
     * conn
     * remoteip, remoteport
     * localip, localport
     * state_machine
     * timeout, retries, maxdgramsize

   * External methods (API)
     * connect(remoteip, remoteport, timeout)
     * disconnect()
     * send(buffer, length, timeout)
     * receive(maxLen)
     * listen(ip, port, timeout)
     * accept(timeout)
     * bind(localip, localport)

 * Exceptions
   * UnknownStateError
   * NotConnectedError
   * TimeoutError
   * RangeError